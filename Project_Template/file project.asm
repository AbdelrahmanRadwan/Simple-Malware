INCLUDE Irvine32.inc
.data

prompt byte "Enter the string to search for it : ",0
prompt1 byte "Enter the Case Mode (1 for ON and 0 for OFF):",0
prompt2 byte "Enter the Whole word Mode (1 for ON and 0 for OFF):",0
filePath byte "c:\\file.txt",0
result byte "This string found in line number : ",0
result1 byte "The line string is : ",0
result2 byte "This string is not found in the file",0
Checker byte 0
temp dword 0
IsFound byte 0
Mode byte 0,0
input byte 1000 dup(?)
buffer byte 10000 dup(?)

tempInput byte 1000 dup(?)
tempBufferLine byte 1000 dup(?)
delimitedBuffer byte 10000 dup(?)

.code

;//this is how to read from the user the input string to search for it in file

ReadFromTheUser PROC C

mov EDX,OFFSET prompt
call writestring
mov EDX,OFFSET input
mov ECX,lengthof input
call readstring
mov EDX,OFFSET prompt1
call writestring
call readchar
call crlf
mov Mode[0],al
mov EDX,OFFSET prompt2
call writestring
call readchar
call crlf
mov Mode[1],al
ret

ReadFromTheUser ENDP

;//this is how to filter the buffer string into Delimitedbuffer string

FillDelimitedBuffer PROC C

mov EDI,offset delimitedBuffer
mov ESI,offset buffer
mov ECX,lengthof buffer
beginingOfLoop:
	mov eax,0
	mov al,byte ptr [esi]
	.if al == 0
		mov byte ptr [edi],'@'
		inc edi
		mov byte ptr [edi],0
		jmp break
	.endif
	mov [edi],al
	inc edi
	inc esi
	mov al,[esi]
	.if al == 0dh
		inc esi
		mov al,[esi]
		.if al == 0ah
			mov byte ptr [edi],'@'
			inc edi
			inc esi
		.endif
	.endif
Loop beginingOfLoop
break:ret

FillDelimitedBuffer ENDP

;//this is how to read from file in the buffer

FillBuffer PROC C

mov EDX,OFFSET filePath
call OpenInputFile
mov EDX,OFFSET buffer
mov ECX,LENGTHOF buffer
call ReadFromFile
call FillDelimitedBuffer
ret

FillBuffer ENDP

;//this is how to match the input string with the line when ( Case = ON & Whole = ON)

COWOCheckIfInputInThisLine PROC C InputStr:ptr byte,Line:ptr byte,Start:dword,Ending:dword

mov temp,edx
mov ecx,Ending
sub ecx,Start
mov esi,InputStr
mov edi,Line
.if Mode[0] == '1'
	add edi,Start
.endif
mov edx,0
beginingOfMatchingLoop1:
	mov eax,0
	mov al,[esi]
	push ecx
	mov ecx,0
	mov ebx,0
	mov bl,[edi]
	mov cl,bl
	.if al == bl
		inc edi
		inc esi
		mov eax,0
		mov al,[esi]
		.if al == 0
			mov ebx,0
			mov bl,[edi]
			.if (bl == ' ' || bl == '@') && (dl == ' ' || dl == 0)
				jmp OUT1
			.endif
		.endif
	.else
		inc edi
		mov esi,InputStr
		mov edx,0
		mov dl,cl
		pop ecx
	.endif
loop beginingOfMatchingLoop1
mov eax,0
mov al,[esi]
.if al != 0
	mov edx,temp
	mov IsFound,0
.else
	OUT1: 
	mov edx,temp
	mov IsFound,1
.endif
ret

COWOCheckIfInputInThisLine ENDP

;//this is how to match the input string with the line when ( Case = OFF & Whole = ON)

CFWOCheckIfInputInThisLine PROC C InputStr:ptr byte,Line:ptr byte,Start:dword,Ending:dword
pushad
mov ecx,1000
mov esi,InputStr
mov edi,offset tempInput
loopingOnInputStr:
	mov eax,0
	mov al,[esi]
	.if al == 0
		jmp LOUT
	.endif
	OR al,00100000b
	mov byte ptr[edi],al
	inc esi
	inc edi
loop loopingOnInputStr
LOUT:
mov al,0
mov [edi],al
mov ecx,Ending
sub ecx,Start
mov esi,Line
add esi,Start
mov edi,offset tempBufferLine
loopingOnLine:
	mov eax,0
	mov al,[esi]
	.if al == '@'
		jmp L1OUT
	.endif
	OR al,00100000b
	mov [edi],al
	inc edi
	inc esi
loop loopingOnLine
L1OUT:
mov al,0
mov [edi],al
invoke COWOCheckIfInputInThisLine,offset tempInput,offset tempBufferLine,Start,Ending
popad
ret

CFWOCheckIfInputInThisLine ENDP


;//this is how to match the input string with the line when ( Case = ON & Whole = OFF)

COWFCheckIfInputInThisLine PROC C InputStr:ptr byte,Line:ptr byte,Start:dword,Ending:dword

pushad
mov ecx,Ending
sub ecx,Start
mov esi,InputStr
mov edi,Line
.if Mode[0] == '1'
	add edi,Start
.endif
beginingOfMatchingLoop:
	mov eax,0
	mov al,[esi]
	mov ebx,0
	mov bl,[edi]
	.if al == bl
		inc esi
		inc edi
		mov eax,0
		mov al,[esi]
		.if al == 0
			jmp Valid
		.endif
	.else
		inc edi
		mov esi,InputStr
	.endif
Loop beginingOfMatchingLoop
mov eax,0
mov al,[esi]
.if al != 0
	popad
	mov IsFound,0
.else
	Valid: popad
	mov IsFound,1
.endif
ret

COWFCheckIfInputInThisLine ENDP

;//this is how to match the input string with the line when ( Case = OFF & Whole = OFF)

CFWFCheckIfInputInThisLine PROC C InputStr:ptr byte,Line:ptr byte,Start:dword,Ending:dword
pushad
mov ecx,1000
mov esi,InputStr
mov edi,offset tempInput
loopingOnInputStr:
	mov eax,0
	mov al,[esi]
	.if al == 0
		jmp LOUT
	.endif
	OR al,00100000b
	mov byte ptr[edi],al
	inc esi
	inc edi
loop loopingOnInputStr
LOUT:
mov al,0
mov [edi],al
mov ecx,Ending
sub ecx,Start
mov esi,Line
add esi,Start
mov edi,offset tempBufferLine
loopingOnLine:
	mov eax,0
	mov al,[esi]
	.if al == '@'
		jmp L1OUT
	.endif
	OR al,00100000b
	mov [edi],al
	inc edi
	inc esi
loop loopingOnLine
L1OUT:
mov al,0
mov [edi],al
invoke COWFCheckIfInputInThisLine,offset tempInput,offset tempBufferLine,Start,Ending
popad
ret

CFWFCheckIfInputInThisLine ENDP


;//this is how to display the line number and the line string if the input string exist in it

DisplayString PROC C String:ptr byte,Start:dword,Ending:dword,LineNumber:dword 

pushad
mov edx,offset result
call writestring
mov eax,LineNumber
call writedec
call crlf
mov edx,offset result1
call writestring
mov edx,String
add edx,Start
mov ecx,Ending
sub ecx,Start
LoopingOnString:
	mov eax,0
	mov al,byte ptr [edx]
	call writechar
	inc edx
loop LoopingOnString
call crlf
popad
ret

DisplayString ENDP 

;//this is how to display error in case the input string isn't found in the whole file

DisplayError PROC C

mov edx,offset result2
call writestring
call crlf
ret

DisplayError ENDP

;//this is how to loop on all the delimited buffer ( all lines in the file ) and check if the string exist in this line or not

SearchForTheInputStringInTheBuffer PROC C

mov edi,OFFSET delimitedBuffer
mov ecx,lengthof delimitedBuffer
mov ebx,0
mov edx,1
mov eax,0
BeginingLoop:
inc edi
inc eax
push edi
.if byte ptr[edi] == 0
	jmp outofloop
.endif
.if byte ptr[edi] == '@'
	push ecx	
	push eax
	push ebx	
	.if Mode[0] == '0' && Mode[1] == '0'
		INVOKE CFWFCheckIfInputInThisLine,offset Input,offset delimitedBuffer,ebx,eax
	.elseif Mode[0] == '0' && Mode[1] == '1'
		INVOKE CFWOCheckIfInputInThisLine,offset Input,offset delimitedBuffer,ebx,eax
	.elseif Mode[0] == '1' && Mode[1] == '0'
		INVOKE COWFCheckIfInputInThisLine,offset Input,offset delimitedBuffer,ebx,eax
	.elseif Mode[0] == '1' && Mode[1] == '1'
		INVOKE COWOCheckIfInputInThisLine,offset Input,offset delimitedBuffer,ebx,eax
	.endif
	pop ebx
	.if isFound == 1
		pop eax
		INVOKE DisplayString,offset delimitedBuffer,ebx,eax,edx
		mov Checker,1
	.else
		pop eax
	.endif

	mov ebx,eax
	inc ebx
	inc edx
	pop ecx
	pop edi
.endif
dec ecx
.if ecx == 0
	jmp outofloop
.endif
jmp BeginingLoop
outofloop:
.if Checker == 0
	call DisplayError
.endif

exit

SearchForTheInputStringInTheBuffer ENDP

;//this is our main code

main PROC

call ReadFromTheUser
call FillBuffer
call SearchForTheInputStringInTheBuffer

exit
main ENDP

END main